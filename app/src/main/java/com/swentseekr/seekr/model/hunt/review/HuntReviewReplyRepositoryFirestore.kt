package com.swentseekr.seekr.model.hunt.review

import android.util.Log
import androidx.annotation.VisibleForTesting
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

/**
 * Firestore-backed implementation of [HuntReviewReplyRepository].
 *
 * This repository stores [HuntReviewReply] objects in the
 * [HuntReviewReplyFirestoreConstants.COLLECTION_PATH] collection and exposes both one-shot and
 * streaming read APIs.
 */
class HuntReviewReplyRepositoryFirestore(
    private val db: FirebaseFirestore,
) : HuntReviewReplyRepository {

  /** Shortcut to the Firestore collection that stores all review replies. */
  private val repliesCollection
    get() = db.collection(HuntReviewReplyFirestoreConstants.COLLECTION_PATH)

  /**
   * Returns a new, unique reply ID generated by Firestore.
   *
   * The ID is created by asking Firestore for a new document reference and reusing its
   * auto-generated ID.
   */
  override fun getNewReplyId(): String {
    return repliesCollection.document().id
  }

  /**
   * Loads all replies associated with the given [reviewId].
   *
   * Replies are fetched by querying the collection on the
   * [HuntReviewReplyFirestoreConstants.FIELD_REVIEW_ID] field and mapping each document to a
   * [HuntReviewReply] instance.
   */
  override suspend fun getRepliesForReview(reviewId: String): List<HuntReviewReply> {
    val snapshot =
        repliesCollection
            .whereEqualTo(HuntReviewReplyFirestoreConstants.FIELD_REVIEW_ID, reviewId)
            .get()
            .await()

    return snapshot.documents.mapNotNull(::documentToReply)
  }

  /**
   * Persists a new [reply] document to Firestore.
   *
   * The [reply.replyId] must be non-blank and is used as the document ID. If the ID is blank, an
   * [IllegalArgumentException] is thrown.
   */
  override suspend fun addReply(reply: HuntReviewReply) {
    require(reply.replyId.isNotBlank()) { HuntReviewReplyFirestoreConstants.REPLY_ID_BLANK_ERROR }

    repliesCollection.document(reply.replyId).set(reply).await()
  }

  /**
   * Updates an existing reply with ID [replyId] using [newReply].
   *
   * If no document exists with the given [replyId], an [IllegalArgumentException] is thrown to
   * signal a logical error in the caller.
   */
  override suspend fun updateReply(replyId: String, newReply: HuntReviewReply) {
    val docRef = repliesCollection.document(replyId)
    val snapshot = docRef.get().await()
    require(snapshot.exists()) { HuntReviewReplyFirestoreConstants.replyNotFoundError(replyId) }
    docRef.set(newReply).await()
  }

  /**
   * Deletes the reply with the given [replyId].
   *
   * If no document exists with the given [replyId], an [IllegalArgumentException] is thrown to
   * signal a logical error in the caller.
   */
  override suspend fun deleteReply(replyId: String) {
    val docRef = repliesCollection.document(replyId)
    val snapshot = docRef.get().await()
    require(snapshot.exists()) { HuntReviewReplyFirestoreConstants.replyNotFoundError(replyId) }
    docRef.delete().await()
  }

  /**
   * Exposes a real-time stream of replies for the given [reviewId].
   *
   * Under the hood this uses a Firestore snapshot listener and wraps it into a cold [Flow]. The
   * flow emits a new list of [HuntReviewReply] values every time the underlying query snapshot
   * changes.
   *
   * The listener is automatically removed when the flow collector is cancelled.
   */
  override fun listenToReplies(reviewId: String): Flow<List<HuntReviewReply>> = callbackFlow {
    val registration =
        repliesCollection
            .whereEqualTo(HuntReviewReplyFirestoreConstants.FIELD_REVIEW_ID, reviewId)
            .addSnapshotListener { snapshot, error ->
              if (error != null) {
                Log.e(
                    HuntReviewReplyFirestoreConstants.LOG_TAG,
                    HuntReviewReplyFirestoreConstants.LISTEN_ERROR_MESSAGE,
                    error,
                )
                return@addSnapshotListener
              }

              if (snapshot != null) {
                trySend(snapshot.documents.mapNotNull(::documentToReply))
              }
            }

    awaitClose { registration.remove() }
  }

  /**
   * Converts a Firestore [document] into a [HuntReviewReply] instance.
   *
   * Returns `null` when required fields are missing or when an exception occurs while reading the
   * document. In case of failure, a log entry is written using
   * [HuntReviewReplyFirestoreConstants.LOG_TAG].
   */
  @VisibleForTesting
  internal fun documentToReply(document: DocumentSnapshot): HuntReviewReply? {
    return try {
      val replyId = document.id
      val reviewId =
          document.getString(HuntReviewReplyFirestoreConstants.FIELD_REVIEW_ID) ?: return null
      val parentReplyId =
          document.getString(HuntReviewReplyFirestoreConstants.FIELD_PARENT_REPLY_ID)
      val authorId =
          document.getString(HuntReviewReplyFirestoreConstants.FIELD_AUTHOR_ID) ?: return null
      val comment =
          document.getString(HuntReviewReplyFirestoreConstants.FIELD_COMMENT)
              ?: HuntReviewReplyFirestoreConstants.DEFAULT_COMMENT_VALUE
      val createdAt =
          document.getLong(HuntReviewReplyFirestoreConstants.FIELD_CREATED_AT)
              ?: HuntReviewReplyFirestoreConstants.DEFAULT_CREATED_AT_VALUE
      val updatedAt = document.getLong(HuntReviewReplyFirestoreConstants.FIELD_UPDATED_AT)
      val isDeleted =
          document.getBoolean(HuntReviewReplyFirestoreConstants.FIELD_IS_DELETED)
              ?: HuntReviewReplyFirestoreConstants.DEFAULT_IS_DELETED_VALUE

      HuntReviewReply(
          replyId = replyId,
          reviewId = reviewId,
          parentReplyId = parentReplyId,
          authorId = authorId,
          comment = comment,
          createdAt = createdAt,
          updatedAt = updatedAt,
          isDeleted = isDeleted,
      )
    } catch (e: Exception) {
      Log.e(
          HuntReviewReplyFirestoreConstants.LOG_TAG,
          HuntReviewReplyFirestoreConstants.DOCUMENT_CONVERSION_ERROR_MESSAGE,
          e,
      )
      null
    }
  }
}
